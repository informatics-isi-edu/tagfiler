
Technical Introduction
-----------------------------


This service can be deployed at an arbitrary "appname" path on a
server (current default "tagfiler"), so all of its access URIs will
have a structure like:

    http(s)://hostname.domain.tld/appname/extrastuff

The remainder of this document covers the format relative to appname,
e.g.  it will just be written /extrastuff instead.

This is an HTTP API, so the HTTP verbs (GET/PUT/POST/DELETE) are
combined with a URI to get a basic function.

There is a core RESTful API, and then an auxilliary layer of HTML form
interactions to help users with browsers access all functions.  There
is one function currently only accessible via the form model, but it
can also be targeted by programmatic clients which know how to do POST
HTML forms to an HTTP server.

Throughout, the RFC 3986 URI encoding rules are used.  Reserved
characters are used as structural syntax in the API, but may be
"percent-encoded" to be placed as raw data payload in any field of the
API.  Clients MUST understand these RFC 3986 rules and the way we use
them: reserved characters meant to structure the API content MUST NOT
be percent-encoded, while reserved characters meant to be escaped in
literal payload data MUST be percent-encoded. Other non-reserved
characters SHOULD NOT be percent encoded in payload data.


Service Conceptual Model
-----------------------------

This service is a combined file repository and metadata or "tag"
registry.  It is oriented around a notion of Named Datasets:

  A. a file dataset is a local file body given a name in the registry

  B. a URL dataset is a remote URL given a name in the registry

A client may retrieve a named dataset, yielding either the actual file
body in the case of file datasets, or yielding an appropriate HTTP
redirect embeddeding the real remote URL in the case of URL datasets.

Every named dataset may have Tags asserted about them.  A simple "no
content" tag is just a label assigned to a dataset, e.g. a tag "funny"
could be asserted on data which amuses somebody.  A typed tag may
associate a simple scalar value with the tag assertion, e.g. a
"length" tag could be asserted with value "5.0" on a dataset.

In the registry, tags must be defined before use. The definition
includes:

   A. the name of the tag, which is unique within the registry

   B. the content type of the tag, e.g. a scalar type or none

   C. whether the tag is Restricted or not

A Restricted Tag can only be asserted about a dataset by the owner of
the dataset.  The concept of dataset owner is defined (somewhat
recursively) as a restricted tag which names the owner.  The service
knows about three special restricted tags:

   1. owner: type text, names the owner of a dataset, and is 
      initialized by the service upon dataset creation.

   2. created: type timestamp, indicates the time the dataset
      was created (or replaced with a new value).

   3. restricted: type boolean, indicates whether a dataset itself
      is restricted.

A Restricted Dataset cannot be retrieved, deleted, nor replaced by
anybody other than the owner.  However, any user may assert
unrestricted tags about any dataset, even if the dataset itself is
restricted.


WARNING: This implementation currently lacks secure management of tag
defintions.  Any user may easily circumvent this security model by
deleting a Restricted Tag definition and recreating it without the
restriction.  This will be addressed before any production release of
the service is considered.

Notational Conventions
----------------------------

In the following API overview, text like "{concept}" represents a
field of the URI and names the content appearing in that field.  Most
undecorated text and URI reserved characters are literal content. A
few bits of special annotation indicate repeating structures:

  [;{tag}]...

this indicates that the sequence of a literal ";" character followed
by a tag can be repeated zero or more times.


RESTful core API
-----------------------------

GET /file/{data id}
   -- fetches data content of file dataset
   -- yields status "303 see other" redirect for URL dataset

PUT /file/{data id}
   -- uploads file content, replacing any existing content or URL
   -- defines data id (name) on first use, otherwise represents
      a replace action

DELETE /file/{data id}
   -- drops dataset, deleting file or URL and any tags on it

PUT /tagdef/{tag}
PUT /tagdef/{tag}?typestr={type}
PUT /tagdef/{tag}?typestr={type}&restricted={bool}
   -- defines a tag
   -- optional type string from a limited set known by service (default none)
      -- without a type, a tag is just a label
      -- with a type, a tag can hold a value
   -- optional restricted flag (default false)
      -- restricted tags can only be asserted on files by file owner

GET /tagdef/{tag}
   -- fetches a tag definition
   -- result content is the typestr={type}&restricted={bool} settings

DELETE /tagdef/{tag}
   -- delete a tag definition and all tag instances

GET /tags/{data id}/{tag}
   -- fetches tag value (which is empty success response for untyped tags)

PUT /tags/{data id}/{tag}
   -- sets tag value (use empty body for untyped tags)

DELETE /tags/{data id}/{tag}
   -- drop a tag

GET /query/{tag}[;{tag}]...
   -- returns result set of datasets having all listed tags asserted
   -- uses HTTP Accept headers to select client-prefered
      alternative representations of query results:
      -- text/html: a human readable list of datasets
      -- text/uri-list: a raw list of datasets by URI


HTML UI layer
-------------------------------

GET /file/
   -- fetches HTML with list of all datasets and links to
      other command pages

GET /file?action=define
   -- fetches a HTML FORM page to define a new dataset by name and type
   -- this form targets POST URL listed next

POST /file?name={data id}&type={type}
   -- data id: text input from form user
   -- type: one of 'file' or 'url' from user drop-down selection
   -- yields "303 see other" redirect to GET URLs listed next

GET /file/{data id}?type=url&action=define
   -- fetches a form to complete creation of a URL dataset
   -- this form targets POST URLs listed next

GET /file/{data id}?type=file&action=define
   -- fetches a form to complete creation of a file dataset
   -- this form targets POST URLs listed next

POST /file/{data id}
   -- a POST of type "multipart/form-data" emulates a PUT for browser clients
   -- uploads file content just like a PUT, using browser file selection
   -- this feature is very limited replacement for PUT

POST /file/{data id}
   -- a POST of type "application/x-www-form-urlencoded" has
      parameters embedded in HTTP headers
   -- param action: put
   -- param url: a user-supplied URL
   -- this invocation registers the user URL for the remote dataset
   -- a programmatic client may directly target this interface 
      without using any previous HTML FORM sequences, which are
      simply helpers to guide browser users to this step

POST /file/{data id}
   -- a POST of type "application/x-www-form-urlencoded" has
      parameters embedded in HTTP headers
   -- param action: delete
   -- this invocation emulates DELETE action

GET /tagdef/
   -- fetches the tag admin page with list of all tag definitions
      and form actions to delete tag definitions or define new tags
GET /tags/{data id}/
   -- fetches dataset admin page with list of all asserted tags
      and forms actions to delete tags or assert tags on this dataset

GET /query?action=edit
GET /query/{query}?action=edit
   -- yields a query editing page
   -- form based query editor starts on empty query, also works on
      existing query string

GET /query/{query1}?tag={tag}&action={action}
   -- yields "303 see other" redirect to /query/{query2}?action=edit
   -- action=add: query2 = query1 + tag
   -- action=delete: query2 = query1 - tag


